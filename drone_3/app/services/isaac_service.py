# FILE: app/services/isaac_service.py
import os
import math
from pxr import Usd, UsdGeom, UsdPhysics, UsdShade, Sdf, Gf, Vt

# Path where OpenSCAD saves STLs
ASSETS_DIR = os.path.abspath("assets")
USD_EXPORT_DIR = os.path.abspath("usd_export")
os.makedirs(USD_EXPORT_DIR, exist_ok=True)

class IsaacService:
    def __init__(self):
        pass

    def generate_drone_usd(self, drone):
        sku = drone['sku_id']
        stage_path = os.path.join(USD_EXPORT_DIR, f"{sku}.usda")
        
        # 1. Create New Stage
        if os.path.exists(stage_path): os.remove(stage_path)
        stage = Usd.Stage.CreateNew(stage_path)
        UsdGeom.SetStageUpAxis(stage, UsdGeom.Tokens.z) # Match OpenSCAD Z-Up
        UsdGeom.SetStageMetersPerUnit(stage, 1.0) # Meters

        # 2. Define Root Xform (The Drone Body)
        root_path = f"/World/{sku.replace('-', '_')}"
        root_prim = UsdGeom.Xform.Define(stage, root_path)
        
        # 3. Apply Physics (Rigid Body) to Root
        # We aggregate mass here for simplicity in V1
        phys_config = drone['technical_data']['physics_config']
        mass_api = UsdPhysics.MassAPI.Apply(root_prim.GetPrim())
        mass_api.CreateMassAttr(phys_config['mass_kg'])
        
        # Center of Mass (from physics service)
        com = phys_config['center_of_mass_offset']
        mass_api.CreateCenterOfMassAttr(Gf.Vec3f(com[0], com[1], com[2]))
        
        rigid_api = UsdPhysics.RigidBodyAPI.Apply(root_prim.GetPrim())
        rigid_api.CreateRigidBodyEnabledAttr(True)

        # 4. Construct Geometry from Scene Graph
        scene_graph = drone['technical_data']['scene_graph']
        
        for i, comp in enumerate(scene_graph['components']):
            comp_type = comp['type']
            
            # Map Component Type to STL Filename (generated by CAD Service)
            stl_filename = self._get_stl_filename(sku, comp_type)
            if not stl_filename: continue

            # Create Prim
            prim_name = f"{comp_type}_{i}"
            prim_path = f"{root_path}/{prim_name}"
            
            # Reference the STL (Isaac handles STL references gracefully)
            # In a prod environment, we might convert STL->USD, but this works.
            mesh = UsdGeom.Mesh.Define(stage, prim_path)
            
            # Absolute path to STL asset
            stl_abs_path = os.path.join(ASSETS_DIR, stl_filename)
            mesh.GetPrim().GetReferences().AddReference(stl_abs_path)

            # Apply Transform (Position & Rotation)
            # Note: Scene Graph is in MM, Isaac is Meters.
            pos_m = [x / 1000.0 for x in comp['pos']]
            rot_deg = [math.degrees(r) for r in comp['rot']]

            xform = UsdGeom.Xformable(mesh)
            xform.AddTranslateOp().Set(Gf.Vec3d(*pos_m))
            # XYZ Euler rotation
            xform.AddRotateXYZOp().Set(Gf.Vec3d(*rot_deg))

            # Apply Material / Color
            self._apply_material(stage, mesh, comp.get('visuals'))

        # 5. Save
        stage.GetRootLayer().Save()
        print(f"   âš¡ Generated USD: {stage_path}")
        return stage_path

    def _get_stl_filename(self, sku, comp_type):
        # Maps logic from render_fleet.py/cad_service.py
        mapping = {
            "FRAME_CORE": "frame_kit",
            "FRAME_ARM": "frame_kit", # Usually part of same kit, logic might vary
            "MOTOR": "motors",
            "PROPELLER": "propellers",
            "BATTERY": "battery",
            "PCB_STACK": "fc_stack",
            "CAMERA": "camera_vtx_kit"
        }
        key = mapping.get(comp_type)
        return f"{sku}_{key}.stl" if key else None

    def _apply_material(self, stage, mesh, visuals):
        if not visuals: return
        
        # Create a Scope for Looks if not exists
        looks_path = "/World/Looks"
        if not stage.GetPrimAtPath(looks_path):
            UsdGeom.Scope.Define(stage, looks_path)
            
        mat_name = f"Mat_{visuals.get('material_type', 'Default')}_{visuals.get('primary_color_hex', 'FFFFFF').lstrip('#')}"
        mat_path = f"{looks_path}/{mat_name}"
        
        material = UsdShade.Material.Define(stage, mat_path)
        pbr_shader = UsdShade.Shader.Define(stage, f"{mat_path}/PBRShader")
        pbr_shader.CreateIdAttr("UsdPreviewSurface")
        
        # Color Conversion
        hex_color = visuals.get('primary_color_hex', '#888888').lstrip('#')
        rgb = tuple(int(hex_color[i:i+2], 16) / 255.0 for i in (0, 2, 4))
        
        pbr_shader.CreateInput("diffuseColor", Sdf.ValueTypeNames.Color3f).Set(Gf.Vec3f(*rgb))
        pbr_shader.CreateInput("roughness", Sdf.ValueTypeNames.Float).Set(0.4)
        pbr_shader.CreateInput("metallic", Sdf.ValueTypeNames.Float).Set(0.5 if visuals.get('material_type') == 'ALUMINUM' else 0.0)

        material.CreateSurfaceOutput().ConnectToSource(pbr_shader.ConnectableAPI(), "surface")
        
        # Bind Material
        UsdShade.MaterialBindingAPI(mesh).Bind(material)